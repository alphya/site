# 値のコピー省略を保証

* cpp17[meta cpp]

## 概要


## 仕様



## 例
```cpp example
// (ここには、言語機能の使い方を解説するための、サンプルコードを記述します。)
// (インクルードとmain()関数を含む、実行可能なサンプルコードを記述してください。そのようなコードブロックにはexampleタグを付けます。)

#include <iostream>

int main()
{
  int variable = 0;
  std::cout << variable << std::endl;
}
```
* variable[color ff0000]
(コードブロック中の識別子に、文字色を付ける例です。)

### 出力
```
0
```
(ここには、サンプルコードの実行結果を記述します。何も出力がない場合は、項目を削除せず、空の出力にしてください。)  
(実行結果が処理系・実行環境によって異なる場合は、項目名を「出力例」に変更し、可能であればその理由も併記してください。)


## この機能が必要になった背景・経緯
関数の戻り値のコピーを発生させない手法として、RVO (Return Value Optimization) やNRVO (Named Return Value Optimization) といった最適化がありました。

```cpp
// RVOの最適化が動作した場合
struct Foo {};

Foo foo()
{
    return Foo();
}

Foo x = foo(); // Foo型のコピーコンストラクタが動作することなくxが初期化される
```
```cpp
// NRVOの最適化が動作した場合
struct Foo { int value = 0; };

Foo foo()
{
    Foo y;
    y.value = 42;
    return y;
}

Foo x = foo(); // Foo型のコピーコンストラクタが動作することなくxが初期化される
```

しかし、これらの最適化はコンパイラに対して許可された動作であって、そのように最適化されることが保証されるものではありません。そのため、実際には(N)RVOによってコピーは起こらないけどコピーコンストラクタは用意しなければならない、といったことになります。

C++1zでは、このようなコピー省略を保証する仕組みが導入されます。そのため、オブジェクトの初期化のために使用するのであれば、コピーもムーブもできない型であっても、関数の戻り値として返せるようになります。

```cpp
// C++1z
struct Foo {
    // Fooはコピーもムーブもできない
    Foo() = default;
    Foo(const Foo&) = delete;
    Foo(Foo&&) = delete;
};

Foo foo()
{
    return Foo();
}

Foo y = foo(); // OK
```

このコピー省略のためには、C++11で右辺値参照を導入するときに規定された「値カテゴリー (value category)」の仕様を利用します。prvalueという一時オブジェクトを表すカテゴリーの値を、オブジェクトの初期化のために使用する場合に、コピーが省略されるという仕様になります。

## 参照
- []()
- []()
- []()
- []()
- []()

